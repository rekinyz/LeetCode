package dp;
import java.util.Arrays;

import junit.framework.Assert;

import org.junit.Test;


public class MaximalRectangle {
    public static int run(char[][] matrix) {
        if (matrix.length == 0) return 0;
        int ret = 0;
        final int m = matrix.length;
        final int n = matrix[0].length;
        int[] h = new int[n]; // 正在处理的行的点的目前最高高度
        int[] l = new int[n];
        int[] r = new int[n];
        Arrays.fill(r,n);
        for (int i = 0; i < m; ++i) {
            // 每次算累计到本行的最大值 = 从右往左
            // 用h记录每个点能到最大高度，用lr计算这个最大高度的能到的宽度，能计算出局部最优，
            // 为了计算这个最大高度的能到的宽度，需要记录这个点自上次有高度开始的历史最大左边0和最小右边1
            // 没有高度，左边就0，右边就可以是最大值（不影响下一行的点）
            // 每行需要记录到目前为止，最左的0和最右的1，这个是left,right，
            // 左边的点，决定当前点的最左的0,所以从左边开始扫描最左的0。
            int left = 0, right = n;
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == '1') {
                    ++h[j]; // 从上往下，有1就增加，碰0就清零
                    //left 记录 0 的下一个位置
                    //第一遍扫描，l是全零，所以记录是
                    // 0,0,2,2,2, left是从左边出发下一个1出现的位置
                    // right应该是从右边出发，下一个1出现的位置
                    // l[]用来累计，第二行 0,0,2,2,0
                    // 本行j是1，如果上一行下一个1出现的位置比
                    l[j] = Math.max(l[j], left);
                } else {
                    left = j + 1;
                    h[j] = 0;
                    l[j] = 0;
                    r[j] = n;
                }
            }
            
            for (int j = n-1; j >= 0; --j){
                if(matrix[i][j] == '1') {
                    r[j] = Math.min(r[j], right);
                    ret = Math.max(ret, h[j]*(r[j] - l[j]));
                } else {
                    right = j;
                }
            }
            System.out.print(Arrays.toString(h));
            System.out.print(Arrays.toString(l));
            System.out.print(Arrays.toString(r));
            System.out.format("l %d r %d ret %d\r\n", left, right, ret);
        }
        return ret;
    }
    
    @Test
    public void test() {
        char[][] a = {
                {'1', '0', '1', '1', '1'},
                {'1', '0', '1', '1', '1'},
                {'0', '0', '1', '1', '1'},
                {'1', '0', '1', '0', '1'},
            };
        Assert.assertEquals(9, run(a));
    }
/*
                {'1', '0', '1', '1', '1'},
                {'1', '0', '1', '1', '0'},
                {'0', '0', '1', '1', '1'},
                {'1', '0', '1', '0', '1'},
[1, 0, 1, 1, 1][0, 0, 2, 2, 2][1, 5, 5, 5, 5]l 2 r 1 ret 3
[2, 0, 2, 2, 0][0, 0, 2, 2, 0][1, 5, 4, 4, 5]l 5 r 1 ret 4
[0, 0, 3, 3, 1][0, 0, 2, 2, 2][5, 5, 4, 4, 5]l 2 r 0 ret 6
[1, 0, 4, 0, 2][0, 0, 2, 0, 4][1, 5, 3, 5, 5]l 4 r 1 ret 6

                {'1', '0', '1', '0', '1'},
                {'1', '0', '1', '1', '0'},
                {'0', '0', '1', '1', '1'},
                {'1', '0', '1', '0', '1'},

[1, 0, 1, 0, 1][0, 0, 2, 0, 4][1, 5, 3, 5, 5]l 4 r 1 ret 1
[2, 0, 2, 1, 0][0, 0, 2, 2, 0][1, 5, 3, 4, 5]l 5 r 1 ret 2
[0, 0, 3, 2, 1][0, 0, 2, 2, 2][5, 5, 3, 4, 5]l 2 r 0 ret 4
[1, 0, 4, 0, 2][0, 0, 2, 0, 4][1, 5, 3, 5, 5]l 4 r 1 ret 4

                {'1', '0', '0', '0', '0'},
                {'1', '0', '1', '1', '0'},
                {'0', '0', '1', '1', '1'},
                {'1', '0', '1', '0', '1'},
[1, 0, 0, 0, 0][0, 0, 0, 0, 0][1, 5, 5, 5, 5]l 5 r 1 ret 1
[2, 0, 1, 1, 0][0, 0, 2, 2, 0][1, 5, 4, 4, 5]l 5 r 1 ret 2
[0, 0, 2, 2, 1][0, 0, 2, 2, 2][5, 5, 4, 4, 5]l 2 r 0 ret 4
[1, 0, 3, 0, 2][0, 0, 2, 0, 4][1, 5, 3, 5, 5]l 4 r 1 ret 4

                {'1', '0', '1', '1', '1'},
                {'1', '0', '1', '1', '1'},
                {'0', '0', '1', '1', '1'},
                {'1', '0', '1', '0', '1'},
[1, 0, 1, 1, 1][0, 0, 2, 2, 2][1, 5, 5, 5, 5]l 2 r 1 ret 3
[2, 0, 2, 2, 2][0, 0, 2, 2, 2][1, 5, 5, 5, 5]l 2 r 1 ret 6
[0, 0, 3, 3, 3][0, 0, 2, 2, 2][5, 5, 5, 5, 5]l 2 r 0 ret 9
[1, 0, 4, 0, 4][0, 0, 2, 0, 4][1, 5, 3, 5, 5]l 4 r 1 ret 9


 */
}
